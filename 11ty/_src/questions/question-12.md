---
title: Question 12
layout: layouts/base.njk
tags:
  - question
  - question-12
---
# Question 12

#### What code fragment codes the equivalent circuit if you remove the barrier in the following QuantumCircuit?

<img alt="Quantum circuit" src="data:image/png;base64,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" />

## Answer Options

**A.**
```python
qc = QuantumCircuit(1,1)
qc.h(0)
qc.s(0)
qc.h(0)
qc.measure(0,0)
```
**B.**
```python
qc = QuantumCircuit(1,1)
qc.measure(0,0)
```
**C.**
```python
qc = QuantumCircuit(1,1)
qc.h(0)
qc.t(0)
qc.tdg(0)
qc.h(0)
qc.measure(0,0)
```
**D.** 
```python
qc = QuantumCircuit(1,1)
qc.h(0)
qc.z(0)
qc.h(0)
qc.measure(0,0)
```

## Question Explanation

This question tests your understanding of the definition of several gates and how they affect the qubit's state.
In particular, for this question you need to know that the $T$ gate is equivalent to half of an $S$ gate.
This is because the $T$ gate, sometimes also called a $\sqrt[4]{Z}$ gate, is equivalent to an $R_{Z}(\frac{\pi}{8})$ gate.
Meanwhile, an $S$ gate, sometimes called a $\sqrt{Z}$ gate is equivalent to an $R_{Z}(\frac{\pi}{4})$ gate.

## References

* [Qiskit Textbook - Single Qubit Gates](https://qiskit.org/textbook/ch-states/single-qubit-gates.html)

## Correct Answer

**A.**
```python
qc = QuantumCircuit(1,1)
qc.h(0)
qc.s(0)
qc.h(0)
qc.measure(0,0)
```

## Answer Explanations

### Imports

### Answer A

```python
qc = QuantumCircuit(1,1)
qc.h(0)  
qc.s(0)  
qc.h(0)
qc.measure(0,0)
```
This creates a circuit that replaces the two $T$ gates from the given `QuantumCircuit` with an $S$.
This is equivalent since two $T$ gates are the same an $S$ gate.

#### Let's take a closer look:


```python
qc = QuantumCircuit(2, 2)

# Use the answer's code fragment to build the first qubit in this circuit
# qc = QuantumCircuit(1,1) # We built a 2 qubit circuit to compare this to the target
qc.h(0)
qc.s(0)
qc.h(0)
# qc.measure(0,0) # The measurement is moved to a single command at the end of the circuit

# Build the initial circuit without a barrier on the second qubit
qc.h(1)
qc.t(1)
qc.t(1)
qc.h(1)
qc.measure([0, 1], [0, 1])

qc.draw("mpl")
```




    
![png](output_13_0.png)
    



Comparing the gates on the two qubits, we see that the two $T$ gates on the second qubit are replaced with an equivalent $S$ gate on the first qubit.
Next, we can plot the Bloch sphere for each qubit and see they are equivalent.


```python
plot_bloch_multivector(
    execute(qc, Aer.get_backend("statevector_simulator")).result().get_statevector(qc)
)
```




    
![png](output_15_0.png)
    



As you can see, the two circuits are functionally equivalent.

### Answer B

```python
qc = QuantumCircuit(1,1)
qc.measure(0,0)
```
This creates a circuit that is still in the $|0\rangle$ state by applying no gates.

#### Let's take a closer look:


```python
qc = QuantumCircuit(2, 2)

# Use the answer's code fragment to build the first qubit in this circuit
# qc = QuantumCircuit(1,1) # We built a 2 qubit circuit to compare this to the target
qc.measure(0, 0)

# Build the initial circuit without a barrier on the second qubit
qc.h(1)
qc.t(1)
qc.t(1)
qc.h(1)
qc.measure(1, 1)

qc.draw("mpl")
```




    
![png](output_19_0.png)
    



Comparing the gates on the two qubits, we see that the first qubit has no gates applied whil the second quabit has the same gates applied as the given circuit.
Next, we can plot the Bloch sphere for each qubit and see they are not equivalent.


```python
plot_bloch_multivector(
    execute(qc, Aer.get_backend("statevector_simulator")).result().get_statevector(qc)
)
```




    
![png](output_21_0.png)
    



As you can see, the Bloch vectors for each circuit are opposite.

### Answer C

```python
qc = QuantumCircuit(1,1)
qc.h(0)  
qc.t(0) 
qc.tdg(0)
qc.h(0)
qc.measure(0,0)
```
This creates a circuit that replaces the second $T$ gates from the given `QuantumCircuit` with an $T\dagger$.
Since $TT\dagger$ is equivalent to Identity $I$, they will negate each other, and this will be equivalent to just applying two $H$ gates

#### Let's take a closer look:


```python
qc = QuantumCircuit(2, 2)

# Use the answer's code fragment to build the first qubit in this circuit
# qc = QuantumCircuit(1,1) # We built a 2 qubit circuit to compare this to the target
qc.h(0)
qc.t(0)
qc.tdg(0)
qc.h(0)
# qc.measure(0,0) # The measurement is moved to a single command at the end of the circuit

# Build the initial circuit without a barrier on the second qubit
qc.h(1)
qc.t(1)
qc.t(1)
qc.h(1)
qc.measure([0, 1], [0, 1])

qc.draw("mpl")
```




    
![png](output_25_0.png)
    



Next, we can plot the Bloch sphere for each qubit and see whether they are equivalent.


```python
plot_bloch_multivector(
    execute(qc, Aer.get_backend("statevector_simulator")).result().get_statevector(qc)
)
```




    
![png](output_27_0.png)
    



As you can see, the Bloch vectors for each circuit are opposite.

### Answer D

```python
qc = QuantumCircuit(1,1)
qc.h(0)
qc.z(0)
qc.h(0)
qc.measure(0,0)
```

This creates a circuit that replaces the two $T$ gates from the given `QuantumCircuit` with a $Z$.
This is would be the equivalent of replacing two $S$ (sometimes called $\sqrt{Z}$) gates or four $T$ (sometimes called $\sqrt[4]{Z}$) gates.

#### Let's take a closer look:


```python
qc = QuantumCircuit(2, 2)

# Use the answer's code fragment to build the first qubit in this circuit
# qc = QuantumCircuit(1,1) # We built a 2 qubit circuit to compare this to the target
qc.h(0)
qc.z(0)
qc.h(0)
# qc.measure(0,0) # The measurement is moved to a single command at the end of the circuit

# Build the initial circuit without a barrier on the second qubit
qc.h(1)
qc.t(1)
qc.t(1)
qc.h(1)
qc.measure([0, 1], [0, 1])

qc.draw("mpl")
```




    
![png](output_31_0.png)
    



Comparing the gates on the two qubits, we see that the two $T$ gates on the second qubit are replaced with a $Z$ gate on the first qubit.
Next, we can plot the Bloch sphere for each qubit and see they are equivalent.


```python
plot_bloch_multivector(
    execute(qc, Aer.get_backend("statevector_simulator")).result().get_statevector(qc)
)
```




    
![png](output_33_0.png)
    



As you can see, the Bloch vectors for each circuit are opposite.
